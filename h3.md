# h3 No Strings Attached

## a) Strings: Extracting Data from passtr
The goal of this task was to analyze the ``passtr`` binary to find a hidden password and flag using static analysis.

- First, I downloaded the ``ezbin-challenges.zip`` and navigated to the directory:

- I typed this command on my terminal
```
unzip ezbin-challenges.zip
cd challenges/passtr
```
- I ran the ``pastr`` script as seen below:
 
 ```
./passtr
```

- I was prompted for a password. Providing incorrect input resulted in a "Sorry, no bonus" message, confirming the binary validates input against a hardcoded value.
  
<img width="804" height="119" alt="Screenshot 2026-02-01 at 8 40 38 AM" src="https://github.com/user-attachments/assets/56121c58-2831-4631-81d2-6fd196ee1926" />

- So then I utilized the ``strings`` command, which scans the binary for sequences of printable characters.

- On my termial I typed:

```
  strings passtr
```

- There were many lines of charachters but luckily the password was very clear, as it shows in the screenshot below:
  
<img width="940" height="136" alt="Screenshot 2026-02-01 at 8 39 51 AM" src="https://github.com/user-attachments/assets/63cfc9fb-a65b-49ac-9624-f69b7030d202" />

- The password appeared to be: sala-hakkeri-321
- So I ran the previous script again ``./paastr``, and entered the password. Here was the successful result as shown below!
  
<img width="914" height="132" alt="Screenshot 2026-02-01 at 8 39 15 AM" src="https://github.com/user-attachments/assets/a0866580-ed71-4b73-a574-9a3fde0d74e6" />
---

## b) Obfuscation: Securing passtr.c

- The original source code stored the password and flag in plaintext.
- To improve security, I would need to create a version where the password is not stored as a literal string, making it invisible to the strings command.
- I researched various methods and discovered that a common technique is to use **XOR cipher** (GeeksforGeeks, 2016) which stores data in a "scrambled" state and only unscramble it at the moment of comparison.
- So I began by modifying the source code. I first ran this command to open up the file:

```
nano passtr.c

```
- Then I chnaged the code from this:

<img width="1038" height="599" alt="Screenshot 2026-02-01 at 9 42 42 AM" src="https://github.com/user-attachments/assets/4548147e-3090-486f-b69b-98de207ee998" />

- To this where I removed the string literal entirely. I stored the password as a sequence of hexadecimal bytes and sed XOR logic, which ensures that the password never exists as a coherent string literal in the compiled file, but rather as a series of non-printable hexadecimal values that only become the password during the CPU's execution.

 ```
#include <stdio.h>
#include <string.h>

int main() {
    // This is the password "sala-hakkeri-321" hidden as binary bytes (XORed with 0x1F)
    unsigned char hidden_pw[] = {0x43, 0x51, 0x54, 0x51, 0x12, 0x58, 0x51, 0x5b, 0x5b, 0x55, 0x42, 0x59, 0x12, 0x23, 0x22, 0x21, 0x00};
    unsigned char key = 0x1F; 
    char input[64];

    printf("What's the password?\n");
    scanf("%63s", input);

    // To compare without using plain text, we XOR the input and check it byte-by-byte
    int match = 1;
    for (int i = 0; i < 16; i++) {
        if ((unsigned char)(input[i] ^ key) != hidden_pw[i]) {
            match = 0;
            break;
        }
    }

    // We also check the length to be precise
    if (match && strlen(input) == 16) {
        printf("Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15}\n");
    } else {
        printf("Sorry, no bonus.\n");
    }

    return 0;
}
```
- To excute the modified code I ran:
  
  ```
  gcc passtr.c -o my_test_binary
  
  ```
  
- By naming the output my_test_binary, I ensured that I was testing a fresh executable generated directly from my modified XOR source code.

-  During execution, the program performs a bitwise XOR comparison against the user's input. This ensures that the password never resides in the binary's data segment as plain text, effectively defeating static analysis via the strings utility.
-  To confirm that the password is not vissible anymore I ean:

```
strings my_test_binary
```
- As you see down below, the password is not in a plain text anymore, its been converted to binary successfully.
  <img width="925" height="314" alt="Screenshot 2026-02-01 at 10 04 28 AM" src="https://github.com/user-attachments/assets/fa18df46-b157-45f6-81bf-5c3b8beb0b3b" />

- To make sure, I ran ``strings my_test_binary | grep "sala"``. The result was empty, which confirms that the password no longer exists as a "string literal." This satisfies the requirement to hide the plaintext from static analysis tools.
<img width="1214" height="73" alt="Screenshot 2026-02-01 at 10 36 34 AM" src="https://github.com/user-attachments/assets/cf06eff7-4031-4b33-9aa4-d8d9506c7190" />
- It works!
---

### Task C: Analysis of packd

- When running the strings utility on the packd binary, the output is significantly different from the original passtr challenge. Most of the binary appears as non-printable characters, which is a common sign of a packed or compressed executable.

- To find the hidden data, I used ``strings`` with a filter to search for the known flag format:

```
strings packd | grep FLAG
```
- 
<img width="517" height="161" alt="Screenshot 2026-02-01 at 10 37 43 AM" src="https://github.com/user-attachments/assets/77b80e6b-f838-4366-be60-68c86e40d012" />

- Even though the binary is packed, the packer often leaves certain metadata or strings visible, or the string was long enough to remain partially uncompressed.
- We can see the password as  ``piilos-An``
- Trying that one after we compile by running:
```
./packd
```
<img width="732" height="196" alt="Screenshot 2026-02-01 at 10 39 41 AM" src="https://github.com/user-attachments/assets/633cf9db-5aa1-4a32-b2c3-023718170118" />

- Initial analysis of the strings output suggested the password was piilos-An. However, the program rejected this input.

- Upon closer inspection using hexdump -C, I observed a 0x0a (newline) followed immediately by a short string

  <img width="1234" height="206" alt="Screenshot 2026-02-01 at 10 55 42 AM" src="https://github.com/user-attachments/assets/c3458759-8e47-4d4f-8007-0b95f2c81894" />


- This reveals that the packer had concatenated multiple strings into a single data block.
- I went back to the ``packd`` file, and I identified ``UPX!!`` listed a multiple of times in the binary.
- When  I searched it up, I discovered that it is a tool (Oberhumer, 2024)
- So I installed it ``sudo dnf install upx`` and ran the decompression command:
  ```
  upx -d packd
  ```
- So now we have 1 file unziped as seen below:
  <img width="1211" height="258" alt="Screenshot 2026-02-01 at 11 10 00 AM" src="https://github.com/user-attachments/assets/ffbc0402-cf84-4924-bac3-c2de5f953923" />

  
-Then I "stringed" the file again:
```
strings packd | grep "piilos"
```
-There is the real password!

<img width="1254" height="237" alt="Screenshot 2026-02-01 at 11 08 31 AM" src="https://github.com/user-attachments/assets/a9351d4b-cd25-41c2-96dd-cec1f923ac10" />

- I ran the program and again and entered the ew password and it worked finally!
  
<img width="1250" height="166" alt="Screenshot 2026-02-01 at 11 06 45 AM" src="https://github.com/user-attachments/assets/497c0104-b0b6-424c-808c-81e666fdc732" />


---
## Refrences
- GeeksforGeeks (2024) XOR Cipher. Available at: https://www.geeksforgeeks.org/xor-cipher/ (Accessed: 1 February 2026).

- Linux Manual Pages (2024) strings(1) - print the sequences of printable characters in files. Available at: https://man7.org/linux/man-pages/man1/strings.1.html (Accessed: 1 February 2026).

- Linux Manual Pages (2024) hexdump(1) - display file contents in ASCII, decimal, hexadecimal, or octal. Available at: https://man7.org/linux/man-pages/man1/hexdump.1.html (Accessed: 1 February 2026).
- Oberhumer, M.F., Molnár, L. and Reiser, J.F. (2024) UPX: the Ultimate Packer for eXecutables. Available at: https://upx.github.io/ (Accessed: 1 February 2026).
  




